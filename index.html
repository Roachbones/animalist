<!doctype html>
<html lang=en>

<head>
    <meta charset=utf-8>
    <title>list animals until failure</title>
    <meta name=description content="hot new brain workout">
    <meta name=viewport content="width=device-width,interactive-widget=resizes-content">
    <style>

html {color-scheme: light dark;}
@media (prefers-color-scheme: light) {
  html {
    --background-color: #eee;
    --foreground-color: #555;
    --confetti-color: #337;
    --modal-background-color: #ddd;
    --urgent-color-1: #e93;
    --urgent-color-2: #c11;
    @media (prefers-contrast: more) {
        --background-color: white;
        --foreground-color: #111;
        --modal-background-color: #eee;
        --urgent-color-1: #c52;
    }
  }
}
@media (prefers-color-scheme: dark) {
  html {
    --background-color: #555;
    --foreground-color: #eee;
    --confetti-color: #99e;
    --modal-background-color: #666;
    --urgent-color-1: #e93;
    --urgent-color-2: #c11;
    @media (prefers-contrast: more) {
        --background-color: #111;
        --foreground-color: white;
        --modal-background-color: #333;
        --confetti-color: #ccf;
    }
  }
}
@media (prefers-contrast: more) {
    #guessbox {
        border-style: solid;
        border-color: var(--foreground-color);
    }
}

img { max-width: 100%; }

body {
    text-align: center;
    background-color: var(--background-color);
    color: var(--foreground-color);
    font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Byrose Sans,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;
}

h1 {
    transition: color 1s;
    &:has(+ p:not(:empty)) { margin-bottom: 0.25em; }
}
#subtitle {
    margin-top: 0.25em;
    font-weight: bold;
    &:empty { display: none; }
}

#rules {
    max-width: 35em;
    display: inline-block;
    text-align: left;
    border-style: solid;
    border-width: 1px;
    border-radius: 1em;
    padding: 0.5em;
    transform-origin: top center;
    &[open] {
        animation-name: wiggle;
        animation-duration: 0.3s;
    }
}
#rules summary { text-align: center; cursor: default; user-select: none;}
#rules:not([open]) summary { cursor: help }
#visualshint {
    animation-name: textappear;
    animation-duration: 1s;
}
#visualshint { display: none; }
body.sky #visualshint, body.water #visualshint { display: block; }
body:not(.daily) #dailyhint { display: none; }
body:not(.restrictive-daily) #restrictivedailyhint { display: none; }

@keyframes textappear { from { font-size: 0 } }

#timerconfetti {
    position: relative;
    display: inline-block;
    color: var(--confetti-color);
    font-weight: bold;
}
.confetto {
    position: absolute;
    transition-property:        top,      left,   opacity, rotate;
    transition-duration:        1s,       1s,     1s,      1s;
    transition-timing-function: ease-out, linear, linear,  ease-out;
    top: -1em; left: 0; opacity: 85%; rotate: 0;
    pointer-events: none;
}
#timer {
    font-family: monospace;
    font-size: 1em;
    /* @media (prefers-reduced-motion: no-preference) { */
        transition-property: font-size;
        transition-duration: 1s;
    /*&::after {
        content: attr(content);
    } doesn't always trigger repaint so let's just set textcontent instead */ 
    &[content^="0:1"] {
        font-size: 2em;
        color: var(--urgent-color-1);
    }
    &[content^="0:0"] {
        font-size: min(31vw, 62vh);
        color: var(--urgent-color-2);
    }
}

#comment {
    display: block;
    min-height: 1.3em;
    padding: 1em;
}
.error {
    color: red;
    font-family: serif;
    rotate: -5deg;
    &::before {
        content: 'Error';
        font-size: xx-large;
        font-weight: bold;
    }
    & p:first-child {
        font-size: small;
    }
}

#guessbox { font-size: 16px; }
#guessbox[disabled] { opacity: 1; } /* Safari workaround (disabled textboxes have low opacity, which ghosts through gameoverscreen) */

#log {
    text-align: left;
    max-width: 35em;
    margin: auto;
    margin-top: 1em;
    li {
        animation-name: bump;
        animation-duration: 0.1s;
        transform-origin: left center;
    }
}
.abdicated {
    list-style-type: circle;
}
.abdication-note {
    font-size: small;
    font-style: italic;
    margin-left: 1em;
}

body.daily {
    #dailypage, #settings-page { display: none; }
}

#dailypage {
    position: absolute;
    left: 0;
    @media (width >= 30em) { top: 0; } // todo generalize w settings-page
    @media (width < 30em) { bottom: 0; }
    padding: 1em;
    & summary {
        text-align: left;
        list-style: none;
        user-select: none;
        &::before {
            content: 'üóìÔ∏è';
            cursor: pointer;
            font-size: xx-large;
        }
        h2 { display: none; }
    }
    &[open] {
        border-right-style: outset;
        @media (width >= 30em) { border-bottom-style: outset; }
        @media (width < 30em) { border-top-style: outset; }
        background-color: var(--modal-background-color);
        & summary > h2 {
            display: inline-block;
            margin-top: 0; margin-bottom: 0;
            margin-left: 1em;
        }
    }
    & button[disabled] {
        rotate: 5deg;
    }
    &:has(button[disabled]) {
        filter: grayscale();
    }
}

#settings-page {
    position: absolute;
    text-align: right;
    right: 0;
    @media (width >= 30em) { top: 0; }
    @media (width < 30em) { bottom: 0; }
    padding: 1em;
    & summary { list-style: none; }
    & label {
        display: block;
        margin: 0.25em;}
}
#gear {
    display: inline-block;
    font-size: xx-large;
    user-select: none;
    cursor: pointer;
    transition: rotate 0.2s ease-out;
    rotate: 0;
    #settings-page[open] & { rotate: -22.5deg; }
}
#settings-page[open] {
    border-left-style: outset;
    @media (width >= 30em) { border-bottom-style: outset; }
    @media (width < 30em) { border-top-style: outset; }
    background-color: var(--modal-background-color);
    & summary {
        margin-bottom: 1em;
    }
}
#settings-page h2 {
    display: none;
    position: absolute;
    left: 1rem;
    top: 0;
}
#settings-page[open] h2 {
    display: inline;
}
body:has(#log li), body.daily {
    #settings-page, #dailypage {
        display: none;
    }
}

#gameoverscreen {
    display: none;
    position: absolute;
    animation: stand .8s;
    animation-timing-function: cubic-bezier(.18,.89,.33,1.33);
    background-color: var(--modal-background-color);
    padding: 1em;
    left: 0; right: 0; margin-inline: auto;
    width: fit-content; max-width: 20em;
    @media (prefers-contrast: more) { border-style: outset; }
    & summary { user-select: none; }
}
body.daily #tryagaintext { display: none; }
body:not(.daily) #tryagainfromdailytext { display: none; }
#dailybutton2 {
    margin: auto;
    margin-top: 0.5em;
    &[disabled] { display: none; }
}
body.daily #dailybutton2 { display: none; }

#copybutton, #epsybutton {
    cursor: copy;
    position: relative; /* for confetti */
}
#mistakes, #about {
    margin-top: 1em;
    & summary { font-size: small }
}
#mistakes {
    #mistakeslog {
        text-align: left;
    }
    display: none;
    &:has(li) { display: block; }
}
#about {
    & summary { user-select: none; }
    &:not([open]) summary { cursor: help; }
}
.pic {
    margin-bottom: 1em;
    &[open] { margin-bottom: 2em; }
}

@keyframes bump {
    0%  {margin-left: 0em;}
    50% {margin-left: -0.2em;}
    to  {margin-left: 0em;}
}
@keyframes wiggle {
    0%  {rotate: 0;}
    25% {rotate: 5deg;}
    50% {rotate: -2.5deg;}
    75% {rotate: 1.25deg;}
    to  {rotate: 0deg;}
}
@keyframes throb {
    0% {scale: 1.2;}
    to {scale: 1;}
}
@keyframes stand {
    from {rotate: x 90deg;} to {rotate: x 0deg;}
}
@keyframes charlie {
    0% { opacity: 1; scale: 1; }
    to { opacity: 0; scale: 999; }
}

#underlay {
    opacity: 0;
    position: fixed; left: 0; top: 0; height: 100vh; width: 100vw;
    transition-property:        background-color, opacity,  filter;
    transition-duration:        4s,               3s,       2s;
    transition-timing-function: ease-in-out,      ease-out, ease-out;
    z-index: -1;
    & { background-image: url("media/tile_ether.svg"); }
    & { background-image: url("media/tile_ether.png"); } /* trying nosvg */
    @media (prefers-color-scheme: dark) {
        background-color: black;
        body.sky & { mix-blend-mode: color; }
    }
    background-size: 2e3px;
    animation-name:            background-north-2e3px, background-east-2e3px;
    animation-duration:        100s,                   calc(pi * e * 10s);
    animation-iteration-count: infinite,               infinite;
    animation-timing-function: linear,                 linear;
}
@keyframes background-north-2e3px {
    0% { background-position-y: 2e3px; }
    to { background-position-y: 0px; }
}
@keyframes background-east-2e3px {
    0% { background-position-x: 0px; }
    to { background-position-x: 2e3px; }
}
@keyframes background-north-8e3px {
    0% { background-position-y: 8e3px; }
    to { background-position-y: 0px; }
}
@keyframes background-east-8e3px {
    0% { background-position-x: 8e3px; }
    to { background-position-x: 2e3px; }
}

#spider {
    display: none;
    position: absolute;
    left: 5em;
    top: -4em;
    text-align: center;
    width: min-content;
}
#spider::before {
    content: "";
    height: 100px;
    display: inline-block;
    border-left: 1px solid black;
    @media (prefers-color-scheme: dark) { border-color: rgb(250, 255, 250, 60%); }
    animation-name: abseil;
    animation-duration: 20s;
    animation-iteration-count: 1;
}
@keyframes abseil {
    0%  { height: 0; }
    50% { height: 30vh; }
    to  { height: 0; }
}

#bat {
    display: none;
    position: absolute;
    right: 10rem;
    bottom: 100vh;
    font-size: xxx-large;
    transform-origin: bottom;
    animation-name: roost;
    animation-duration: 10s;
}
@keyframes roost {
    10% { transform: rotateX(180deg); }
    90% { transform: rotateX(180deg); }
    to  { }
}

snail-race {
    display: block;
    position: absolute;
    bottom: 0;
    left: 0;
    overflow: hidden;
    width: 100%;
}
#snail {
    display: none;
    margin-left: calc(100vw + 1em);
    font-size: xx-large;
    animation-name: crawl;
    animation-duration: 300s;
    animation-timing-function: ease-out;
}
@keyframes crawl { to { margin-left: -1em; } }

body:has(#disablebgbox:checked) #underlay { display: none; }

#dailypage {display:none;}

    </style>
    <link rel=stylesheet href=evolution.css>
    <script src=lower_title_to_id.js></script>
    <script src=id_to_title.js></script>
    <script src=mononyms.js></script>
    <script src=parent.js></script>
    <script src=eggs.js></script>
    <script src=pics.js></script>
    <script src=thanks.js></script>
    <script>

function newGame() {
    guessed_ids = []          // ids of animals guessed so far
    abdicated_ids = new Set() // ids of animals guessed but later overridden by narrower guesses
    guessed_id_to_li = {}     // guessed animal id ‚Üí the <li> listing it
    guessed_descendant = {}   // disallowed parent ‚Üí its already-guessed descendant
    guesses = []              // text guesses so far
    wrong_guesses = []        // see above, but just wrong ones
    correct_guesses = []      //                     correct ones
    score = 0;
    scorespan.innerText = 0;
    underlay.vibrance = 0;
    trivia.textContent = '';
    
    startTime = undefined;
    endTime = undefined;
    log.innerText = '';
    mistakeslog.innerText = '';
    guessbox.value = '';
    guessbox.disabled = null;
    h1.style = '';
    gameoverscreen.style = '';
    visualshint.style = '';
    underlay.style = '';
    spider.style = '';
    bat.style = '';
    document.body.classList = [];
    document.body.style = null;
    dog_index = 0;
    h1.innerHTML = 'list animals until failure';
    dailypage.style = '';

    updateDaily();
    currentChallenge = null;
    subtitle.innerHTML = '';
    
    guessbox.focus()

    if (location.hash=='#showmistakesfornova') mistakes.style='';
    if (1==1) dailypage.style.display='block';
}

// big databases:
// LOWER_TITLE_TO_ID: lowercase title to id
// ID_TO_TITLE: id to sentence-case title
// PARENT: id to parent's id

function* lineage(guess_id) {
    yield guess_id;
    var ancestor_id = PARENT[guess_id];
    while (PARENT[ancestor_id]) {
        yield ancestor_id;
        ancestor_id = PARENT[ancestor_id];
    }
}
function debugLineage(guess) {
    for (let i of lineage(LOWER_TITLE_TO_ID[guess]))console.log(i, ID_TO_TITLE[i]);
}

function ancests(possible_ancestor_id, guess_id) {
    // Whether possible_ancestor_id ancests (is an ancestor of) guess_id.
    var ancestor_id = PARENT[guess_id];
    while (PARENT[ancestor_id]) {
        if (ancestor_id == possible_ancestor_id) { return true; }
        ancestor_id = PARENT[ancestor_id];
    }
}

function any_ancests(possible_ancestor_ids, guess_id) {
    // Whether any of possible_ancestor_ids ancests (is an ancestor of) guess_id.
    var ancestor_id = PARENT[guess_id];
    while (PARENT[ancestor_id]) {
        if (possible_ancestor_ids.has(ancestor_id)) { return true; }
        ancestor_id = PARENT[ancestor_id];
    }
}

function triggerAnimation(e, animation) {
    e.style.animation = null;
    e.offsetTop;
    e.style.animation = animation;
}

function wiggle(e) { triggerAnimation(e, 'wiggle 0.2s'); }
function throb(e) { triggerAnimation(e, 'throb 0.2s'); }

function choice(l) { return l[Math.floor(Math.random()*l.length)]; }

function appendp(element, text) {
    let p = document.createElement('p');
    p.textContent = text;
    element.append(p);
    return p;
}

function tryAttempt() {
    try {
        attempt();
    } catch (error) {
        console.error(error);
        let errorReport = document.createElement('div');
        errorReport.classList.add('error');
        appendp(errorReport, error);
        if (!guessed_ids.length) {
            appendp(errorReport, 'Try refreshing?');
        }
        comment.append(errorReport);
    }
}



function any_ancests(possible_ancestor_ids, guess_id) {
    // Whether any of possible_ancestor_ids ancests (is an ancestor of) guess_id.
    var ancestor_id = PARENT[guess_id];
    while (PARENT[ancestor_id]) {
        if (possible_ancestor_ids.has(ancestor_id)) { return true; }
        ancestor_id = PARENT[ancestor_id];
    }
}

function attempt() {
    var verbatim_guess = guessbox.value;
    var guess = guessbox.value.trim().toLowerCase().replaceAll("-"," ").replaceAll('‚Äô',"'").replaceAll(/ +/g, ' ');
    if (!guess) { return; }
    guesses.push(guess);
    console.log(guess);
    if (guess=='crab') {
        comment.innerText = "(Carcinization makes it hard to define ‚Äúcrab‚Äù, so I'm going to pretend you said ‚Äúbrown crab‚Äù.)";
        guess = 'brown crab';
    }
    
    if (LOWER_TITLE_TO_ID.hasOwnProperty(guess)) {
        var guess_id = LOWER_TITLE_TO_ID[guess];
        
        // It's an animal. But does it conflict with one already guessed?
        // It could be already guessed itself, or a parent of a guess, or a child of a guess.
        
        // Is it already guessed?        
        if (guessed_ids.includes(guess_id)) {
            comment.innerText = 'Already said ' + ID_TO_TITLE[guess_id] + '.';
            var egg_message = equivalence_egg_message(guess, guess_id);
            if (egg_message) { comment.innerText+=' '+egg_message; }
            if (egg_message=='NO!') comment.innerText=egg_message // or could check for all-caps?
            console.log(' ‚ô¢ '+comment.innerText);
            wiggle(guessed_id_to_li[guess_id]);
            return;
        }

        // Is it an ancestor of a previous guess?
        if (guessed_descendant[guess_id]) {
            comment.innerText = 'Already said more specific animal: ' + ID_TO_TITLE[guessed_descendant[guess_id]];
            var egg_message = ancestry_egg_message(guess, guessed_descendant[guess_id], guess_id);
            if (egg_message) { appendp(comment, egg_message); }
            console.log(' ‚ô¢ '+comment.innerText);
            // wiggle guessed descendants
            var i = 0;
            for (prev_guess_id of guessed_ids) {
                i += 1;
                if (i>99) { break; }
                var ancestor_id = PARENT[prev_guess_id];
                while (PARENT[ancestor_id]) {
                    if (ancestor_id == guess_id) {
                        wiggle(guessed_id_to_li[prev_guess_id]);
                        break;
                    }
                    ancestor_id = PARENT[ancestor_id];
                }
            }
            return;
        }
        
        // If this is a challenge run, does the guess conform to the challenge?
        if (currentChallenge) {
            let rejection = currentChallenge.rejection(guess_id, guess);
            if (rejection) {
                if (ID_TO_TITLE[guess_id].toLowerCase().replaceAll("-"," ") != guess) {
                    rejection += ' (Understood as '+ ID_TO_TITLE[guess_id] + '.)';
                }
                comment.innerText = rejection;
                wiggle(h1);
                return;
            }
        }
        
        // Guess is valid.
        // But is it a child of a guess? If so, its parent shall abdicate, and no reward shall be dispensed.
        var ancestor_id = PARENT[guess_id];
        var reward = true;
        while (PARENT[ancestor_id]) {
            if (guessed_ids.includes(ancestor_id) && !abdicated_ids.has(ancestor_id)) {
                abdicated_ids.add(ancestor_id);
                var li = guessed_id_to_li[ancestor_id]
                var s = document.createElement('s');
                s.append(li.childNodes[0]);
                li.append(s)
                var abdication_note = document.createElement('span');
                abdication_note.classList.add('abdication-note');
                abdication_note.innerHTML = ' Replaced by more specific ' + ID_TO_TITLE[guess_id];
                guessed_id_to_li[ancestor_id].append(abdication_note);
                guessed_id_to_li[ancestor_id].classList.add('abdicated');
                comment.innerText = 'Replaced vaguer animal: ' + ID_TO_TITLE[ancestor_id]
                var egg_message = ancestry_egg_message(guess, guess_id, ancestor_id);
                if (egg_message) { appendp(comment, egg_message); }
                reward = false;
                break;
            }
            ancestor_id = PARENT[ancestor_id];
        }
        
        if (reward) {
            score += 1;
            if (endTime != undefined) { grantIncrement(); }
            underlay.vibrance += 100;
        }
        
        // Display any easter egg text for this guess.
        var egg_message = valid_guess_egg_message(guess, guess_id);
        if (egg_message) {
            if (comment.innerText) { comment.innerText += "."; } 
            comment.innerText += ' ' + egg_message;
        }
        
        // Forbid this guess in the future.
        guessed_ids.push(guess_id);
        
        // Forbid this guess's parents.
        var ancestor_id = PARENT[guess_id];
        while (PARENT[ancestor_id]) {
            guessed_descendant[ancestor_id] = guess_id;
            ancestor_id = PARENT[ancestor_id];
        }
        
        // Create a li for the guess
        li = document.createElement('li');
        if (ID_TO_TITLE[guess_id].toLowerCase().replaceAll("-"," ") == guess) {
            li.innerText = ID_TO_TITLE[guess_id];
        } else {
            li.innerText = verbatim_guess + ' ‚Üí ' + ID_TO_TITLE[guess_id];
        }
        guessed_id_to_li[guess_id] = li;
        egg_manipulate_li(li, guess, guess_id);
        progress_egg();
        log.prepend(li);
        correct_guesses.push(guess);
        
        // Update UI.
        guessbox.value='';
        scorespan.innerText = score;
        
        for (word of (guess+' '+ID_TO_TITLE[guess_id]).replace('bird','-').split(/[ -]/)) {
            if (CSS.supports('color', word) && word!='field' && word!='canvas' && word!='mark' && word!='highlight') {
                h1.style.color = word;
                break;
            }
        }
    } else {
        comment.innerText = invalid_guess_egg_message(guess) || "I don't know that animal.";
        if (wrong_guesses[wrong_guesses.length - 1] != guess) {
            wrong_guesses.push(guess);
            let li = document.createElement('li');
            li.innerText = guess;
            mistakeslog.append(li);
        }
        return;
    }
    if (startTime == undefined) {
        startTime = Date.now();
        endTime = startTime + (currentChallenge?.duration_s || initial_time_control.value)*1000;
    }
    updateTimer();
}

function uncomment() {
    comment.textContent='';
}

function grantIncrement(ms) {
    increment = currentChallenge?.increment_s || increment_control.value;
    ms ||= increment*1000;
    if (!ms) {return;}
    endTime += ms;
    summonConfetto('+' + Math.floor(ms/1000), timerconfetti);
}

function summonConfetto(text, parent) {
    var confetto = document.createElement('span');
    confetto.classList.add('confetto');
    confetto.innerText = text;
    parent.append(confetto);
    setTimeout(()=>{confetto.remove()}, 2000);
    setTimeout(()=>{
        confetto.style.top = '-5em';
        confetto.style.left = (Math.random()*4-2) + 'em';
        confetto.style.opacity = 0;
        confetto.style.rotate = (Math.random()**2-0.5) + 'rad';
    },10)
}

function updateUnderlay() {
    underlay.style.opacity = underlay.style.backgroundImage ? score/7 : -1 + (score/50);
    if (score == 60) { visualshint.style.display = 'block'; }
    underlay.vibrance = Math.max(0, underlay.vibrance*0.99);
    underlay.style.filter = 'saturate(' + (1+Math.floor(underlay.vibrance/90)) + ')';
}

var secondsLeft;
function updateTimer() {
    if (startTime == undefined) {
        initial_time_control.value = Math.max(1, initial_time_control.value);
        secondsLeft = currentChallenge?.duration_s || initial_time_control.value;
    } else {
        let prevSecondsLeft = secondsLeft;
        secondsLeft = (endTime - Date.now())/1000;
        if (
            navigator.vibrate &&
            (Math.floor(prevSecondsLeft) > Math.floor(secondsLeft)) &&
            secondsLeft < 9 &&
            secondsLeft > 0
        ) {
            navigator.vibrate(7*Math.floor(9-secondsLeft));
        }
    }
    if (secondsLeft <= 0) {
        endGame();
        secondsLeft = 0;
    }
    let timerText = Math.floor(secondsLeft/60) + ":" + Math.floor(secondsLeft%60).toString().padStart(2,0);
    timer.setAttribute('content', timerText);
    timer.textContent = timerText;
}

function emojiSummary() {
    var summary = '';
    /* var mononymmed_ancestors = new Set(); */
    for (guessed_id of guessed_ids) {
        if (abdicated_ids.has(guessed_id)) { continue; }
        var ancestor_id = guessed_id;
        while (PARENT[ancestor_id]) {
            if (MONONYMS[ancestor_id]) {
                summary += choice(MONONYMS[ancestor_id]);
                break;
            }
            ancestor_id = PARENT[ancestor_id];
        }
    }
    return summary;
}

DEFAULT_DURATION_S = 60;
DEFAULT_INCREMENT_S = 6;

function generateShareString() {
    var timerDisclaimer = (initial_time_control.value!=DEFAULT_DURATION_S || increment_control.value!=DEFAULT_INCREMENT_S) ? '‚è±Ô∏è'+initial_time_control.value+'/'+increment_control.value : '';
    s = 'https://rose.systems/animalist';
    if (document.body.classList.contains('daily')) s += '#today';
    s += '\n' + timerDisclaimer;
    s += '\n' + currentChallenge?.attributivizeScore?.() || (score + ' animal'+(score!=1?'s':'')+' listed');
    s += '\n' + emojiSummary();
    return s;
}

function copyToClipboard(text, confettoTarget) {
    if (!navigator.clipboard) { summonConfetto('error >~<"', confettoTarget); }
    return navigator.clipboard.writeText(text)
        .then(()=>{ summonConfetto('copied!', confettoTarget); })
        .catch(()=>{ summonConfetto('error >_<"', confettoTarget); });
}

var thankIndex;
function cycleThank() {
    thankIndex ||= score;
    thankIndex = (thankIndex + 1) % THANKS.length;
    thank.innerHTML = THANKS[thankIndex];
}

var shareString;
function endGame() {
    if (guessbox.disabled) { return; }
    fetch(
        "https://guestbook.rose.systems/animals",
        {
            method: 'POST',
            headers: {'Content-Type':'application/json'},
            body: [currentChallenge?.shortname || '', JSON.stringify({guesses: JSON.stringify(guesses)})],
        }
    )
    guessbox.disabled = true;
    navigator.vibrate && navigator.vibrate(999);
    queue_final_trivia();
    cycleThank();
    shareString = generateShareString();
    copybutton.style.display = navigator.clipboard ? null : 'none';
    discord.style.display = score > 50 ? '' : 'none';
    gameoverscreen.style.display = 'block';
    comment.innerText = '';
    if (currentChallenge?.key) {
        localStorage['c_'+currentChallenge.key] = currentChallenge.shortname + ' ' + score;
    }
}

function load() {
    newGame();
    setInterval(updateTimer);
    setInterval(updateUnderlay, 100);
    if (location.hash=='#today' && !localStorage['c_'+daily.key]) {
        startDaily();
    }
}


// DAILIES
daily = null;
currentChallenge = null;

function updateDaily(debugOffset=0) {
    today = new Date();
    today.setDate(today.getDate() + debugOffset);
    daily = challengeForToday();
    daily.key = 'daily_' + today.getFullYear() + '_' + today.getMonth() + '_' + today.getDate();
    dailydesc.textContent = today.toLocaleDateString();
    if (localStorage['c_'+daily.key]) {
        dailybutton.disabled = true;
        dailybutton2.disabled = true;
        dailypage.title = "Already attempted daily for " + today.toLocaleDateString() + ". Come back tomorrow";
        dailydesc.textContent += ' ‚úî';
        return;
    } else {
        dailybutton.disabled = false;
        dailybutton2.disabled = false;
        dailypage.title = '';
        dailydesc.textContent += '‚ùó';
    }
}

wordchain_challenge = {
    shortname: 'wordchain',
    title: 'list animals in a word chain',
    subtitle: 'each guess must begin with the last letter of the previous guess',
    rejection: wordchain_rejection,
    attributivizeScore: ()=>{ score + ' animal' + (score==1 ? '' : 's') + ' wordchained' }
}
function wordchain_rejection (_guess_id, guess) {
    if (!correct_guesses.length) return;
    let prevGuess = correct_guesses[correct_guesses.length-1];
    let requiredInitial = prevGuess.slice(prevGuess.length-1);
    if (guess.slice(0,1) != requiredInitial) {
        return "That doesn't begin with " + requiredInitial + ".";
    }
}

function singleInitialChallenge(letter) {
    const LETTER = letter.toUpperCase();
    return {
        shortname: LETTER + '-animals',
        title: 'list animals starting with ' + LETTER,
        subtitle: 'each guess must begin with ' + LETTER,
        rejection: function (_guess_id, guess) {
            if (!guess.startsWith(letter)) return "That doesn't start with "+LETTER+".";
        },
        attributivizeScore: ()=> score + ' ' + LETTER + '-animal' + (score==1 ? '' : 's') + ' listed'
    }
}

alphabeticalChallenge = {
    shortname: 'alphabetical',
    title: 'list animals in alphabetical order',
    subtitle: 'abcdefghijklmnopqrstuvwxyz',
    rejection: function (_guess_id, guess) {
        let prevGuess = correct_guesses[correct_guesses.length-1];
        if (prevGuess && guess.localeCompare(prevGuess)<0) return "That alphabetically precedes" + prevGuess + ".";
    },
    attributivizeScore: ()=> score + (score==1 ? '' : 's') + ' listed alphabetically'
}

invisibleTimerChallenge = {
    shortname: 'invisibletimer',
    title: 'list animals invisibly timed',
    subtitle: "the timer is invisible. maybe it's easier without the big red countdown",
    rejection: ()=>{}
}

function challengeForToday() {
    if (1==0) return {
        shortname: '0.5s-1s',
        title: 'half-second test challenge',
        duration_s: 0.5, increment_s: -1,
        rejection: ()=>{}
    }
    
    let month = today.getMonth(); let date = today.getDate(); let day = today.getDay();
    
    // Specific dates (by which I mean month and day. No wait, day means weekday, uh,)
    if (month==2-1 && date==29) return singleTaxonChallenge('frog', 'leap day challenge');
    if (day==8 && month==8-1) return {
        shortname: 'arachnids/octopuses',
        title: 'list arachnids & octopuses until failure',
        rejection: function(guess_id) {
            if (!any_ancests([LOWER_TITLE_TO_ID.arachnid, LOWER_TITLE_TO_ID.octopus], guess_id)) {
                return "Not arachnid nor octopus.";
            }
        },
        duration_s: 8, increment_s: 8
    }

    insect_challenge = singleTaxonChallenge('insect');
    insect_challenge.rejection = function(guess_id) { // defined a function but now overriding. Optimize?
        for (const ancestor of lineage(guess_id)) {
            if (ancestor==LOWER_TITLE_TO_ID.insect) return;
            if (ancestor==LOWER_TITLE_TO_ID.spider) return "Spiders are arachnids, not insects.";
            if (ancestor==LOWER_TITLE_TO_ID.scorpion) return "Scorpions are arachnids, not insects.";
            if (ancestor==LOWER_TITLE_TO_ID.arachnid) return "That's an arachnid, not an insect.";
            if (ancestor==LOWER_TITLE_TO_ID.hexapoda) return "That's a hexapod, but not all hexapods are insects.";
            if (ancestor==LOWER_TITLE_TO_ID.crustacea) return "That's a crustacean, but not an insect.";
            if (ancestor==LOWER_TITLE_TO_ID.arthropoda) return "That's an arthropod, but not all arthropods are insects.";
        }
        return 'Not an insect.';
    }
    
    arachnid_challenge = singleTaxonChallenge('arachnid');
    arachnid_challenge.rejection = function(guess_id, guess) {
        for (const ancestor of lineage(guess_id)) {
            if (ancestor==LOWER_TITLE_TO_ID.arachnid) return;
            if (ancestor==LOWER_TITLE_TO_ID.insect) return "That's an insect. Arachnids have 8 legs, not 6.";
            if (ancestor==LOWER_TITLE_TO_ID.crustacea) return "That's a crustacean, but not an arachnid.";
            if (ancestor==LOWER_TITLE_TO_ID.arthropoda) return "That's an arthropod, but not an arachnid.";
            if (guess=='vriska' || guess=='vriska serket' || guess=='mindfang') return "Not spidertrolls.";
        }
        return 'Not an arachnid.';
    }
    arachnid_challenge.duration_s = 30; arachnid_challenge.increment_s = 8;
    
    
    if (day==0) return singleTaxonChallenge('bird', "it's bird sunday"); // Bird Sunday
    if (day==1) return singleTaxonChallenge('mammal', 'Mammal Monday');
    if (day==4) return singleTaxonChallenge('arthropod', 'Exoskeletoned invertebrates.'); // Arthropod Thursday
    
    if (day==6) return { // Speedrun Saturday
        shortname: '30s+3s',
        title: 'list animals fast',
        subtitle: 'speedrun saturday',
        duration_s: 30, increment_s: 3,
        rejection: ()=>{},
        attributivizeScore: ()=> score + ' animal' + (score==1 ? '' : 's') + ' listed fast (30s+3s)'
    }
    
    if (date==1) return singleTaxonChallenge('snake');
    if (date==2) return singleTaxonChallenge('corvid', 'crows, ravens, rooks, magpies, jackdaws, jays, treepies, choughs, & nutcrackers');
    if (date==3) return singleTaxonChallenge('bee');
    if (date==4) return singleTaxonChallenge('beetle');
    if (date==5) return singleTaxonChallenge('primate');
    if (date==6) return insect_challenge;
    if (date==7) return singleTaxonChallenge('ruminant', 'hooved grazers');
    if (date==8) return arachnid_challenge;
    if (date==9) return wordchain_challenge;
    
    if (date==10) return {
        shortname: '10-1',
        title: 'list animals faster!',
        duration_s: 10, increment_s: 1,
        rejection: ()=>{},
        attributivizeScore: ()=>{ score + ' animal' + (score==1 ? '' : 's') + ' listed faster (10s+1s)' }
    }
    
    if (date==11) return {
        shortname: 'non-mammal',
        title: 'list non-mammal animals until failure',
        rejection: function(guess_id, guess) {
            if (ancests(LOWER_TITLE_TO_ID.mammal, guess_id)) return "That's a mammal.";
        }
    };
    if (date==12) return singleTaxonChallenge('beetle', 'insects with hardened wing-cases');
    if (date==13) {
        let letters = 'etaoinshrdlcumwfg';
        letter = letters[(day + today.getFullYear()) % letters.length];
        return singleInitialChallenge(letter);
    }
    if (date==14) return singleTaxonChallenge('crustacean');
    if (date==15) return singleTaxonChallenge('lepidopteran', 'ü¶ã butterflies & moths ü¶ã');
    if (date==16) return singleTaxonChallenge('mollusk', 'gastropods, cephalopods, & bivalves');
    if (date==17) return singleTaxonChallenge('felid', 'cats, big or small');
    if (date==18) return singleTaxonChallenge('canid', 'doglike creatures');
    if (date==19) return singleTaxonChallenge('amphibian', 'members of the class Amphibia');

    // img ref for this one?
    //if (date==20) return singleTaxonChallenge('carnivoran', 'an order of placental mammals specialized primarily in eating flesh; includes felids, canids, and others');
    if (date==20) {
        c = singleTaxonChallenge('monotreme', 'egg-laying mammals');
        c.duration_s = 5; c.increment_s = 3;
        return c;
    }
    //if (date==21) return singleTaxonChallenge('wasp', 'not including bees & ants');
    if (date==22) return {
        shortname: '-fish',
        title: 'list animals whose names end in -fish',
        rejection: function(guess_id, guess) {
            if (guess.endsWith('fish') || ID_TO_TITLE[guess_id].endsWith('fish')) return;
            return "That doesn't end in ‚Äúfish‚Äù.";
        },
        attributivizeScore: ()=>{ score + ' fish listed' }
    };
    if (date==24) {
        c = singleTaxonChallenge('bear', "there are only like 8 of them");
        c.duration_s = 25; c.increment_s = 5;
        return c;
    }
    if (date==25) return singleTaxonChallenge('rodent', 'from Latin <i>r≈çdƒìns</i>, ‚Äúgnawing‚Äù');
    if (date==26) return alphabeticalChallenge;
    if (date==27) return singleTaxonChallenge('sauropsid', 'bird & reptiles');
    if (date==28) return singleTaxonChallenge('marsupial');
    if (date==29) return {
        shortname: '60-0',
        title: 'list animals in one minute',
        subtitle: 'no time bonus for listed animals',
        duration_s: 60, increment_s: 0,
        rejection: ()=>{},
        attributivizeScore: ()=>{ score + ' animal' + (score==1 ? '' : 's') + ' listed in 1 min' }
    }

    if (date==30) return {
        shortname: 'invertebrate',
        title: 'list invertebrates until failure',
        subtitle: 'spineless animals',
        rejection: function(guess_id, guess) {
            if (ancests(LOWER_TITLE_TO_ID.vertebrata, guess_id))return "That's a vertebrate.";
        }
    };
    
    //if (date==30) return singleTaxonChallenge('myriapod', 'centipedes & millipedes');
    if (date==31) return singleTaxonChallenge('owl');
    
    if (date==32) {
        c = singleTaxonChallenge('ant');
        c.rejection = (guess_id, guess) => {
            if (guess=='velvet ant') return "Velvet ants aren't actually ants. Sorry.";
            if (!ancests(LOWER_TITLE_TO_ID.ant, guess_id)) return "Not an ant.";
        };
        c.duration_s = 20;
        c.increment_s = 4;
        return c;
    }

    if (date==NaN) return singleTaxonChallenge('tullimonstrum');
    return insect_challenge;
}

// bad?
// maybe ancestor_name, overrides=null?
function singleTaxonChallenge(ancestor_name, subtitle, ancestor_article, ancestor_name_plural) {
    ancestor_name_plural ||= ancestor_name + 's';
    ancestor_article ||= ancestor_name.match(/^[aeiou]/) ? 'an' : 'a';
    return {
        shortname: ancestor_name,
        title: "list " + ancestor_name_plural + " until failure",
        subtitle: subtitle,
        attributivizeScore: function() {
            if (score==1) return score + ' ' + ancestor_name + ' listed';
            return score + ' ' + ancestor_name_plural + ' listed';
        },
        rejection: function(guess_id) {
            if (!ancests(LOWER_TITLE_TO_ID[ancestor_name], guess_id)) {
                return "Not " + ancestor_article + " " + ancestor_name + ".";
            }
        }
    }
}

function startDaily() {
    if (localStorage['c_'+daily.key]) { // todo could be a method on daily
        return alert('Error: challenge ' + daily.key + ' (' + daily.shortname + ') already attempted >.<;');
    }
    startChallenge(daily);
}

function startChallenge(challenge) {
    if (!challenge) { alert("error challenge not defined bwehh >.<'"); }
    challenge.duration_s ||= DEFAULT_DURATION_S;
    challenge.increment_s ||= DEFAULT_INCREMENT_S;
    challenge.attributivizeScore ||= ()=> score + 'animal' + (score==1 ? '' : 's') + ' listed';
    currentChallenge = challenge;
    h1.innerHTML = challenge.title;
    subtitle.innerHTML = challenge.subtitle || '';
    document.body.classList.add('daily');
    if (challenge.rejection(LOWER_TITLE_TO_ID.tullimonstrum, 'tullimonstrum') || challenge.rejection(LOWER_TITLE_TO_ID.human, 'human')) {
        document.body.classList.add('restrictive-daily');
    }
    dailypage.open = false;
    
    throb(h1);
    if (challenge.duration_s != DEFAULT_DURATION_S) throb(timer);
}


    </script>
</head>

<body onload=load()>
    <div id=underlay></div>
    <noscript>This game requires JavaScript. Or, if you've superior taste, take out a pen and paper and start listing animals.</noscript>
    <h1 id=h1>list animals until failure</h1>
    <p id=subtitle></p>
    <details id=rules>
        <summary>List as many animals as you can.</summary>
        <p><b>Animals must have Wikipedia articles.</b>
        <p><b>You have limited time, but get more time for each animal listed.</b> When the timer runs out, that's game over.
        <p><b>No overlapping terms.</b>
           For example, if you list ‚Äúbear‚Äù and ‚Äúpolar bear‚Äù, you get no point (or time bonus) for the latter.
           But you can still get a point for a second kind of bear. Order doesn't matter.
        <p id=dailyhint><b>This is a daily challenge.</b><span id=restrictivedailyhint> Not all animals are eligible.</span>
        <p id=visualshint><b style=color:var(--urgent-color-1)>Ignore the extraneous visuals.</b>
           Focus on naming animals.
    </details> 
    
    <details id=dailypage>
        <summary title='Daily challenge'><h2>Daily challenge</h2></summary>
        <p id=dailydesc></p>
        <button id=dailybutton onclick=startChallenge(daily)>TRY DAILY CHALLENGE</button>
    </details>
    
    <details id=settings-page>
        <summary title=Settings><h2>Settings</h2><span id=gear>‚öôÔ∏è</span></summary>
        <label>initial time (s): <input type=number size=2 id=initial_time_control min=1 value=60></label>
        <label>time increment (s): <input type=number size=2 id=increment_control min=0 value=6></label>
        <label><input type=checkbox id=disablebgbox></input>disable animated backgrounds</label>
        <button onclick="initial_time_control.value=60;increment_control.value=6;disablebgbox.checked=0">reset to defaults</button>
    </details>
   
    <p>Score: <span id=scorespan>0</span></p>
    
    <div style=height:1.5em>
        <game-timer id=timer role=timer></game-timer>
        <div id=timerconfetti></div>
    </div>
    
    <three-dimensional style=perspective:30rem;display:block>
        <section id=gameoverscreen>
            <h2>game over</h2>
            <section id=trivia></section>
            <button id=copybutton onclick=copyToClipboard(shareString,copybutton)>copy emoji summary</button>
            <button id=epsybutton onclick=copyToClipboard(log.innerText,epsybutton)>copy list</button>
            <button id=tryagainbutton onclick=newGame()>
                <span id=tryagaintext>try again</span>
                <span id=tryagainfromdailytext>play normal-style</span>
            </button>
            <button id=dailybutton2 onclick=newGame();startDaily()>try today's daily challenge</button>
            <details id=mistakes style=display:none><summary>mistakes</summary>
                <ul id=mistakeslog></ul>
                <p>(If they're my fault, check Wikipedia & <a href=https://rose.systems/contact target=_blank>tell me what to fix</a>.)</p>
            </details>
            <details id=about onToggle=if(event.newState.at(5)){cycleThank();}><summary>about this game</summary>
                <p>By <a href=https://rose.systems>Vivian Rose</a>.
                <p>Uses Wikipedia and Wikidata, plus a lot of hand-tuning. No LLMs involved.
                <p><a href=https://rose.systems/contact>Contact me</a> with bug reports, questions, suggestions, and praise.
                <p id=thank style=font-size:small></p>
                <p id=discord>There's also <a href=https://discord.gg/vTEvrkNunZ>a fanmade Discord server</a>.</p>
            </details>
        </section>
    </three-dimensional>

    <output id=comment for=guessbox></output>
    <!--<div id=yetanothercontainer style=overflow-x:clip>-->
    <solar-system>
        <!--<div id=belt><div id=orbiter><div id=kettle><img id=prey src=media/bird.svg><img id=predator src=media/eagle.svg></div></div></div>-->
        <input id=guessbox autofocus autocomplete=off onkeydown="if(event.key==`Enter`){tryAttempt()}" oninput=uncomment()>
    </solar-system>
    <ul id=log></ul>
    <!--</div>-->
    
    <div id=spider aria-hidden>üï∑Ô∏è</div>
    <div id=bat aria-hidden>ü¶á</div>
    <snail-race><div id=snail aria-hidden>üêå</div></snail-race>
</body>

<!--that's right, buddy....
    unquoted tag attributes....
    autonomous custom element....
    omission of optional closing tags....
    named element access on the Window object....
    why, you ask?
    because it's in the spec-->

</html>
